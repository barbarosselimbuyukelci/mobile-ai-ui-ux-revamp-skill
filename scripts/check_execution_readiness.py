#!/usr/bin/env python3
"""
Validate execution-discipline artifacts for implementation runs.
Compatible with Python 3.9+.
"""

import argparse
import re
from pathlib import Path
from typing import Dict, List, Set, Tuple


REQUIRED_EXEC_FILES = [
    "12-execution-manifest.md",
    "14-implementation-completeness-matrix.md",
    "15-artifact-intake.md",
    "16-execution-batch-plan.md",
    "17-implementation-change-log.md",
]

REQUIRED_READ_ARTIFACTS = [
    "01-intent-inference.md",
    "02-problem-frame.md",
    "03-user-task-model.md",
    "04-mobile-flows.md",
    "05-screen-specs.md",
    "06-visual-system.md",
    "07-ux-copy.md",
    "08-quality-gates.md",
    "09-handoff-package.md",
    "10-verification.md",
    "11-release-summary.md",
    "12-execution-manifest.md",
]


def parse_markdown_table(text: str) -> Tuple[List[str], List[Dict[str, str]]]:
    lines = [line.strip() for line in text.splitlines() if line.strip().startswith("|")]
    if len(lines) < 2:
        return [], []

    header = [col.strip() for col in lines[0].strip("|").split("|")]
    rows: List[Dict[str, str]] = []
    for line in lines[2:]:
        cols = [col.strip() for col in line.strip("|").split("|")]
        if len(cols) != len(header):
            continue
        rows.append({header[i]: cols[i] for i in range(len(header))})
    return header, rows


def find_section_tables(text: str) -> Dict[str, Tuple[List[str], List[Dict[str, str]]]]:
    sections: Dict[str, str] = {}
    current = "root"
    bucket: List[str] = []
    for line in text.splitlines():
        h = re.match(r"^\s{0,3}#{2,3}\s+(.+?)\s*$", line.strip())
        if h:
            sections[current] = "\n".join(bucket)
            current = h.group(1).strip().lower()
            bucket = []
            continue
        bucket.append(line)
    sections[current] = "\n".join(bucket)

    out: Dict[str, Tuple[List[str], List[Dict[str, str]]]] = {}
    for name, content in sections.items():
        header, rows = parse_markdown_table(content)
        if header and rows:
            out[name] = (header, rows)
    return out


def validate_required_files(artifact_dir: Path) -> List[str]:
    issues: List[str] = []
    for name in REQUIRED_EXEC_FILES:
        if not (artifact_dir / name).exists():
            issues.append("Missing required execution artifact: {0}".format(name))
    return issues


def validate_artifact_intake(path: Path) -> List[str]:
    issues: List[str] = []
    text = path.read_text(encoding="utf-8", errors="ignore")
    tables = find_section_tables(text)
    target = tables.get("artifact read log")
    if not target:
        return ["15-artifact-intake.md: missing 'Artifact Read Log' table"]

    _, rows = target
    read_artifacts: Set[str] = set()
    good_status = {"done", "complete", "completed", "read", "yes"}

    for row in rows:
        artifact = row.get("artifact", "").strip()
        status = row.get("read_status", "").strip().lower()
        if artifact:
            read_artifacts.add(artifact)
            if artifact in REQUIRED_READ_ARTIFACTS and status not in good_status:
                issues.append(
                    "15-artifact-intake.md: artifact '{0}' read_status is not complete".format(
                        artifact
                    )
                )

    missing = [a for a in REQUIRED_READ_ARTIFACTS if a not in read_artifacts]
    if missing:
        issues.append(
            "15-artifact-intake.md: missing artifacts in read log -> {0}".format(
                ", ".join(missing)
            )
        )

    return issues


def validate_batch_plan(path: Path) -> List[str]:
    issues: List[str] = []
    text = path.read_text(encoding="utf-8", errors="ignore")
    tables = find_section_tables(text)
    target = tables.get("batch plan")
    if not target:
        return ["16-execution-batch-plan.md: missing 'Batch Plan' table"]

    _, rows = target
    non_empty = []
    for row in rows:
        batch = row.get("batch", "").strip()
        reqs = row.get("requirements", "").strip()
        files = row.get("target_files", "").strip()
        checks = row.get("acceptance_checks", "").strip()
        if batch and (reqs or files or checks):
            non_empty.append(row)

    if len(non_empty) < 3:
        issues.append("16-execution-batch-plan.md: less than 3 populated batches")

    plan_source_ok = "generated by planning skill/agent" in text.lower()
    if not plan_source_ok:
        issues.append("16-execution-batch-plan.md: missing plan source declaration")

    return issues


def validate_change_log(path: Path) -> List[str]:
    issues: List[str] = []
    text = path.read_text(encoding="utf-8", errors="ignore")
    tables = find_section_tables(text)
    target = tables.get("batch change log")
    if not target:
        return ["17-implementation-change-log.md: missing 'Batch Change Log' table"]

    _, rows = target
    progressed = 0
    for row in rows:
        status = row.get("status", "").strip().lower()
        reqs = row.get("requirement_ids", "").strip()
        files = row.get("changed_files", "").strip()
        if status and status != "pending" and (reqs or files):
            progressed += 1

    if progressed == 0:
        issues.append("17-implementation-change-log.md: no batch marked as progressed")

    return issues


def main() -> int:
    parser = argparse.ArgumentParser(description="Validate execution-discipline artifacts.")
    parser.add_argument("artifact_dir", help="Path to run-artifacts/<run-id> folder")
    args = parser.parse_args()

    artifact_dir = Path(args.artifact_dir)
    if not artifact_dir.exists() or not artifact_dir.is_dir():
        print("ERROR: artifact_dir is invalid: {0}".format(artifact_dir))
        return 2

    issues: List[str] = []
    issues.extend(validate_required_files(artifact_dir))

    intake = artifact_dir / "15-artifact-intake.md"
    if intake.exists():
        issues.extend(validate_artifact_intake(intake))

    plan = artifact_dir / "16-execution-batch-plan.md"
    if plan.exists():
        issues.extend(validate_batch_plan(plan))

    change_log = artifact_dir / "17-implementation-change-log.md"
    if change_log.exists():
        issues.extend(validate_change_log(change_log))

    if issues:
        print("Execution readiness: FAIL")
        for issue in issues:
            print("- {0}".format(issue))
        return 1

    print("Execution readiness: PASS")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
